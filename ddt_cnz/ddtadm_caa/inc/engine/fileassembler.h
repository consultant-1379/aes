//	********************************************************
//
//	 COPYRIGHT Ericsson 2015
//	All rights reserved.
//
//	The Copyright to the computer program(s) herein
//	is the property of Ericsson 2015.
//	The program(s) may be used and/or copied only with
//	the written permission from Ericsson 2015 or in
//	accordance with the terms and conditions stipulated in
//	the agreement/contract under which the program(s) have
//	been supplied.
//
//	********************************************************

#ifndef DDTADM_CAA_INC_ENGINE_FILEASSEMBLER_H_
#define DDTADM_CAA_INC_ENGINE_FILEASSEMBLER_H_

#include "dataassembler.h"

namespace engine
{
	class FileFormat;

	/**
	 * @class FileAssembler
	 *
	 * @brief The FileAssembler class is derived from @c DataAssembler
	 * Manages the file assembler activities .
	 *
	 */
	class FileAssembler: public DataAssembler
	{
		public:

			///  Constructor
			FileAssembler(const std::string& dataSourceName, const std::string& producerName, const int& stopEvent, DataSink* sink);

			///  Destructor
			virtual ~FileAssembler();

			/**
			 *	@brief life cycle
			 */
			virtual int svc();

		private:
			enum BufferTransmission
			{
				COMPLETE_FILE 	= 0,
				PARTIAL_BUFFER = 1
			};

			/** @brief
			 *
			 *	This method transmits the file locally assembled via its Data Sink towards a remote destination
			 *
			 *  @param chunk: output buffer to send
			 *
			 *  @param chunkSize: data length in byte
			 *
			 *  @param recordCounter: number of records stored into the data chunk
			 *
			 *  @return ERR_NO_ERRORS on success otherwise a proper error code
			 *
			 *	@remarks Remarks
			 */
			int transmitFile(unsigned char* chunk, const uint32_t& chunkSize, const uint32_t& recordCounter, const BufferTransmission& requestedTransmission);

			/** @brief
			 *
			 *	This method takes needed actions before sending data such as opening the remote file
			 *
			 *  @return ERR_NO_ERRORS on success otherwise a proper error code
			 *
			 *	@remarks Remarks
			 */
			int onOutgoingFile();

			/** @brief
			 *
			 *	This method takes needed actions once data has been sent. It closes the remote file.
			 *
			 *  @param recordCounter: number of records stored into the transmitted file
			 *
			 *	@remarks Remarks
			 */
			int onTransmittedFile(const uint32_t& recordCounter);

			/** @brief
			 *
			 *	This method requires opening of a remote file
			 *
			 *  @return ERR_NO_ERRORS on success otherwise a proper error code
			 *
			 *	@remarks Remarks
			 */
			int openRemoteFile();

			/** @brief
			 *
			 *	This method requires closing of the remote file
			 *
			 *  @return ERR_NO_ERRORS on success otherwise a proper error code
			 *
			 *	@remarks Remarks
			 */
			int closeRemoteFile();

			/** @brief
			 *
			 *	This method refreshes output and file format data
			 *
			 *	@remarks Remarks
			 */
			void refreshFormattingData();

			/** @brief
			 *
			 *	This method checks and handles possible catastrophic errors generated by the underlying CoreMW Checkpoint
			 *
			 *	@param readerError: error code set by the store namespace
			 *
			 *	@remarks Remarks
			 */
			void handleError(int readerError);

			/** @brief
			 *
			 *	This method sleeps, but wakes up in case of shutdown.
			 *
			 *	@param seconds to sleep
			 *
			 *	@return true if the shutdown event has been received.
			 *
			 *	@remarks Remarks
			 */
			bool sleepOnInternalError(int seconds);

		private:

			class RemoteContainer
			{

			 public:

				RemoteContainer() : m_name(), m_currentFileSizeInByte(0U), m_buffer(), m_bufferedRecords(0) {};

				void resetFileBuffer()
				{
					m_currentFileSizeInByte = 0U;
					m_buffer.clear();
					m_bufferedRecords = 0U;
				};

				void reset()
				{
					m_name.clear();
					resetFileBuffer();
				};

				void increaseSizeOfByte(const uint32_t& addBytes) { m_currentFileSizeInByte += addBytes; };

				uint32_t getSizeInByte() const { return m_currentFileSizeInByte; };

				std::string getName() const { return m_name; };

				const char* getNameAsChar() const { return m_name.c_str(); };

				void setName(const std::string& name) { m_name.assign(name); };

				bool isMaxSizeInByteReached(const uint32_t& maxSize) const { return (maxSize <= m_currentFileSizeInByte); };

				bool isOpen() { return !m_name.empty(); };

				void addChunk(unsigned char* chunk, const uint32_t& chunkSize, const uint32_t& recordCounter)
				{

					if ( 0 != recordCounter )
					{
						m_buffer.insert(m_buffer.end(), chunk, chunk + chunkSize);
						increaseSizeOfByte(chunkSize);
						m_bufferedRecords += recordCounter;
					}
				}

				unsigned char * getBuffer() { return &m_buffer[0];};

				uint32_t getRecordCounter() const {return m_bufferedRecords;};

				uint32_t getBufferSizeInByte() const {return m_buffer.size();};

				void resetBuffer()
				{
					m_buffer.clear();
					m_bufferedRecords = 0U;
				}

			 private:

				// current remote file name
				std::string m_name;

				// Current remote file size in Byte
				uint32_t m_currentFileSizeInByte;

				// Current buffered records
				std::vector<unsigned char> m_buffer;

				// Number of records currently in buffer
				uint32_t m_bufferedRecords;
			};

			/// m_refreshData
			bool m_refreshData;

			// Formatting info of the file
			boost::shared_ptr<FileFormat> m_fileFormat;

			/// Remote File
			RemoteContainer m_remoteFile;
	};

} /* namespace engine */

#endif /* DDTADM_CAA_INC_ENGINE_FILEASSEMBLER_H_ */
