//******************************************************************************
//
// NAME
//      bgwrpc.cpp
//
//  COPYRIGHT Ericsson AB, Sweden 2004.
//  All rights reserved.
//
//  The Copyright to the computer program(s) herein 
//  is the property of Ericsson Utvecklings AB, Sweden.
//  The program(s) may be used and/or copied only with 
//  the written permission from Ericsson Utvecklings AB or in 
//  accordance with the terms and conditions stipulated in the 
//  agreement/contract under which the program(s) have been 
//  supplied.

// .DESCRIPTION 
//  Handles RPC parts specific to the Billing Gateway (BGw)
//  implementation.

// DOCUMENT NO
//  190 89-CAA 109 0507

// AUTHOR 
//  1999-07-05 by I/LD Gunnar Andersson

// CHANGES
//
//	RELEASE REVISION HISTORY
//
//	REV NO  DATE    NAME    DESCRIPTION
//          010530  qabhall Method checkConnection added INGO3 GOH.
//			060906	xtbmale	Replaced Distinct RPC with Netbula RPC:
//							- Replaced aes_cdh_rpc.h, aes_cdh_rpc_clnt.c and aes_cdh_rpc_xdr 
//                            with files generated by Netbula rpcgen. (Link with pwrpc32.lib)
//							- The use of clnt_geterror has been replaced by clnt_spcreateerror 
//                            for Netbula compatibility (Netbula Clnt.h)

// SEE ALSO 
//  CDHRPC
//
//******************************************************************************


#include <bgwrpc.h>
#include <ace/Get_Opt.h>
#include <rpc/rpc.h>
#include <string.h>
#include <event.h>
#include <parameter.h>
#include <sstream>
#include <aes_gcc_variable.h>
#include <blockpairindex.h>
#include <destinationalarm.h>
#include <blockpairmappermanager.h>
#include <transdest.h>
#include <AES_CDH_Contactor.h>
#include <transferagent.h>
#include <aes_cdh_common.h>
#include "aes_cdh_logger.h"
#include "aes_cdh_tracer.h"

using namespace std;

namespace AES_CDH_RPC {

                const std::string RPC_CONNECTION_ERROR = "Connection lost to Remote System: ";
                const std::string RPC_SEND_ERROR = "RPC SEND ERROR"; 
                const std::string RPC_SEND_FAILED = "Sending procedure failed towards remote system: ";
                const std::string  ERROR_CODES = "Error codes: "; 
}

AES_CDH_TRACE_DEFINE(AES_CDH_BGWRPC);
//******************************************************************************
//  BGWRPC()
//******************************************************************************
//##ModelId=3DE49B4C02CB
BGWRPC::BGWRPC():
bgwrpc(NULL),
client(NULL),
bpMapper(NULL),
transMutex(0),
oldRecordNumber(APPLID_MAX + 1),
clusterName(),
BGWRPCopen(0),
inBGWRPCopen(false)
{
	transMutex = new (std::nothrow) ACE_Recursive_Thread_Mutex();
	BGWRPCopen = new (std::nothrow) ACE_Manual_Event();

	OmHandler myOmHandler;
	if( myOmHandler.Init() == ACS_CC_FAILURE )
	{
		AES_CDH_LOG(LOG_LEVEL_ERROR, "OmHandler initialize failed");
		AES_CDH_TRACE_MESSAGE("Leaving ...");
		bgwProgramNumber=AES_CDH_BGW_RPC_ProgramNumber;
		bgwTimeout = AES_CDH_BGW_RPC_Timeout;
	}
	string myRDn;
	myRDn=AES_GCC_Util::dnOfBlockTransferM;
	AES_CDH_TRACE_MESSAGE("The value of myRDN fetched from IMM : %s",myRDn.c_str());
	ACS_APGCC_ImmObject myRDObj;
	myRDObj.objName =  (myRDn) ;
	if( myOmHandler.getObject(&myRDObj) == ACS_CC_FAILURE )
	{
		AES_CDH_LOG(LOG_LEVEL_ERROR,  "Unable to retrieve attributes for %s",myRDObj.objName.c_str());
		AES_CDH_TRACE_MESSAGE("Unable to retrieve attributes for %s",myRDObj.objName.c_str());
	}
	std::vector<ACS_APGCC_ImmAttribute>::iterator attributesListItr2;
	for ( attributesListItr2 = myRDObj.attributes.begin();
			attributesListItr2 != myRDObj.attributes.end() ;
			++attributesListItr2 )
	{
		if((*attributesListItr2).attrName ==BGWRPC_PGM_NUMBER )
		{
			if((*attributesListItr2).attrValuesNum != 0)
			{

				bgwProgramNumber = *reinterpret_cast<int *>((*attributesListItr2).attrValues[0]);
				AES_CDH_TRACE_MESSAGE("The value of bgwProgramNumber fetched from IMM : %lu",bgwProgramNumber);
			}
		}
		if((*attributesListItr2).attrName ==BGWRPC_TIMEOUT )
		{
			if((*attributesListItr2).attrValuesNum != 0)
			{

				bgwTimeout = *reinterpret_cast<int *>((*attributesListItr2).attrValues[0]);
				AES_CDH_TRACE_MESSAGE("The value of bgwProgramNumber fetched from IMM : %lu",bgwProgramNumber);
			}
		}


	}
	myOmHandler.Finalize();
	if(bgwProgramNumber==0)
	{
		bgwProgramNumber=AES_CDH_BGW_RPC_ProgramNumber;
	}
	if( bgwTimeout == 0 )
	{
		bgwTimeout = AES_CDH_BGW_RPC_Timeout;
	}

	if (getClusterName(clusterName) == false)
	{
		clusterName = "UNKNOWN";
	}
}


//******************************************************************************
//  ~BGWRPC()
//******************************************************************************
//##ModelId=3DE49B4C02D5
BGWRPC::~BGWRPC()
{
	AES_CDH_TRACE_MESSAGE("Entering...");
	this->close_internal();
	delete BGWRPCopen;
	delete transMutex;
	AES_CDH_TRACE_MESSAGE("Leaving...");
}


//******************************************************************************
//  clone()
//******************************************************************************
//##ModelId=3DE49B4C02E0
TransferAgent* BGWRPC::clone(void)
{
	return (new BGWRPC(*this));
}


//******************************************************************************
//  checkConnection()            
//******************************************************************************
//##ModelId=3DE49B4D0177
AES_CDH_ResultCode BGWRPC::checkConnection(void)
{
	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;

	rCode = openForCheckConnection();
	return rCode;

}   


//******************************************************************************
//  define()
//******************************************************************************
//##ModelId=3DE49B4C0325
AES_CDH_ResultCode BGWRPC::define(int &argc, char *argv[], const bool define, const bool recovery)
{    
	AES_CDH_TRACE_MESSAGE("Entering ...");

	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;

	rCode = CDHRPC::define(argc, argv, define, recovery);

	AES_CDH_TRACE_MESSAGE("Leaving ...");

	return rCode;
}


//******************************************************************************
// remove()
//******************************************************************************
//##ModelId=3DE49B4C0330
AES_CDH_ResultCode BGWRPC::remove()
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);

	AES_CDH_TRACE_MESSAGE("Entering ...");

	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;
	rCode = CDHRPC::remove();
	AES_CDH_TRACE_MESSAGE("Leaving ...");
	return rCode;
}


//******************************************************************************
//  openForCheckConnection()
//  INGO3 AES qabulfg
//  Method for check connection functions
//******************************************************************************
//##ModelId=3DE49B4D018B
AES_CDH_ResultCode BGWRPC::openForCheckConnection()
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);

	AES_CDH_TRACE_MESSAGE("Entering ...");

	AES_CDH_ResultCode returnCode = AES_CDH_RC_OK;
	if (client == NULL)
	{
		AES_CDH_TRACE_MESSAGE("Before: conP = new AES... &create ");

		AES_CDH_Contactor conP(this,const_cast<char *>(hostAddress.c_str()),bgwProgramNumber);
		client = conP.getResult();

		AES_CDH_TRACE_MESSAGE("After: this->create() getResult");

		if (client != NULL)
		{
			AES_CDH_TRACE_MESSAGE("client != NULL");

			struct timeval tv;

			tv.tv_sec = bgwTimeout;
			tv.tv_usec = 0;

			if (!clnt_control((CLIENT*)client, CLSET_TIMEOUT, (char*)&tv)) //llv5
			{
#ifdef DEBUGTEST
				cout<< "Failed clnt_control : " <<clnt_spcreateerror("BGWRPC")<<endl;
#endif
				close_internal();
			}

			// hefe
			close_internal();
		}
		else
		{
			returnCode = AES_CDH_RC_CONNECTERR;
		}
	}

	AES_CDH_TRACE_MESSAGE("Leaving ...");
	return returnCode;
}


//******************************************************************************
//  open()
//******************************************************************************
AES_CDH_ResultCode BGWRPC::open(int& argc, char* argv[], unsigned int &blockFromOpen)
{
	BGWRPCopen->reset();
	inBGWRPCopen = true;
	hEvInstanceClosed->reset();

	AES_CDH_TRACE_MESSAGE("Entering");

	AES_CDH_ResultCode returnCode = AES_CDH_RC_OK;
	int opt;
	int nFlag = 0;
	string streamName;
	string destSetName;

	ACE_Get_Opt getopt(argc, argv, "f:m:n:o:");

	while ((opt = getopt()) != EOF)
	{
		switch (opt) 
		{
		case 'o':
		{
			// Name of transferQueue
			streamName = getopt.optarg;
			break;
		}
		case 'f':
		{
			// some string
			mainFileName = getopt.optarg;
			break;
		}
		case 'm':
		{
			break;
		}
		case 'n':
		{
			subFileName = getopt.optarg;
			nFlag++;
			break;
		}
		case '?':
		{
			/* Just ignore other options */
			break;
		}
		default:
		{
			Event::report(AES_CDH_intProgFault, "INTERNAL PROGRAM ERROR",
					"Internal program error in BGWRPC::open",
					"-");
			inBGWRPCopen = false;
			BGWRPCopen->signal();
			return AES_CDH_RC_INTPROGERR;
		}
		}
	}

	destSetName = destinationPtr->getDestSetName();

	if (clusterName.size() + mainFileName.size() + destSetName.size() + 2 
			> AES_IFO_FILE_NAME_SIZE)
	{
		Event::report(AES_CDH_fileNameFault, "FILE NAME ERROR",
				"File name too long : ", clusterName + "_" + mainFileName +
				"_" + destSetName);

		inBGWRPCopen = false;
		BGWRPCopen->signal();
		return AES_CDH_RC_FILENAMETOOLONG;
	}


	(void) ::strcpy(fileName, clusterName.c_str());
	(void) ::strcat(fileName, "_");
	(void) ::strcat(fileName, streamName.c_str());
	(void) ::strcat(fileName, "_");
	(void) ::strcat(fileName, destSetName.c_str());

	if (!(mainFileName == ""))   //CR_265
	{
		// Not empty, add it to remote base file name
		(void) ::strcat(fileName, "_");
		(void) ::strcat(fileName, mainFileName.c_str());
	}

	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	AES_CDH_TRACE_MESSAGE(  "BGWRPC::open() with theSourceID = %s", fileName);

	cdhOutVar.theSourceID = fileName;
	bpMapper = BlockPairMapperManager::instance()->getMapper(destinationPtr->getDestSetName());

	// If we did not get any memory, we can not proceed
	if (bpMapper == NULL)
	{
		Event::report(AES_CDH_memoryFault, "MEMORY ALLOCATION PROBLEM",
				"Storage space for block mapping could not be allocated", "-");

		inBGWRPCopen = false;
		BGWRPCopen->signal();
		return AES_CDH_RC_INTPROGERR;
	}

	string RPCName = this->hostAddress;
	bpMapper->makeRPCName(RPCName);
	bool b = bpMapper->open(fileName, RPCName);
	if (b != true)
	{
		bpMapper->close();
		inBGWRPCopen = false;
		BGWRPCopen->signal();
		return AES_CDH_RC_PHYSFILEERR;
	}

	AES_CDH_TRACE_MESSAGE("BGWRPC::open() Before: if (client == NULL)");

	// If we don't have a client, we need to create one
	if (client == NULL)
	{
		AES_CDH_Contactor conP(this,const_cast<char *>(hostAddress.c_str()),bgwProgramNumber);
		client = conP.getResult();

		AES_CDH_TRACE_MESSAGE("After: this->create()");

		if (client != NULL)
		{
			AES_CDH_TRACE_MESSAGE("client != NULL");
			struct timeval tv;

			tv.tv_sec = bgwTimeout;
			tv.tv_usec = 0;
			if (!clnt_control((CLIENT*)client, CLSET_TIMEOUT, (char*)&tv))
			{
				close_internal();
			}
			AES_CDH_TRACE_MESSAGE("after, client != NULL");
		}
	}

	// If there is no connection
	if (client == NULL)
	{
		ostringstream err_back;
		Event::report(AES_CDH_rpcConnectFault, "RPC CONNECT ERROR",err_back.str(), "-");
		returnCode = AES_CDH_RC_CONNECTERR;
	}
	else
	{
		AES_CDH_TRACE_MESSAGE("calling updateBlockID");
		if (updateBlockID() != AES_CDH_RC_OK)
		{
			close_internal();
			inBGWRPCopen = false;
			BGWRPCopen->signal();
			return AES_CDH_RC_CONNECTERR;
		}

		unsigned int id;

		// get CDRBid value (== lastTransactionID)
		if (cdhOutVar.theBlockID == 0)
		{
			id = 4294967295;
		}
		else
		{
			id = cdhOutVar.theBlockID - 1;
		}


		AES_CDH_TRACE_MESSAGE("CDRBid fetched from BGW-server:%d ", id);

		if (! bpMapper->validFile())
		{
			string RPCName = this->hostAddress;
			bpMapper->makeRPCName(RPCName);
			unsigned int status = bpMapper->getFileStatus(RPCName);
			if (status == 0)
			{
				// INVALID
				bpMapper->setCDRBid(id, RPCName);
				AES_CDH_LOG(LOG_LEVEL_DEBUG, "file INVALID, CDRBid set to %d", id);
			}
			else if (status == 2)
			{
				// CHANGED
				bpMapper->setCDRBidOnly(id, RPCName);
				AES_CDH_LOG(LOG_LEVEL_DEBUG, "file CHANGED, CDRBid set to %d ", id);
			}
		}

		blockFromOpen = bpMapper->getApplBlockId(id);

		if (oldRecordNumber == APPLID_MAX + 1)
		{
			oldRecordNumber = bpMapper->getApplBlockId();
			AES_CDH_TRACE_MESSAGE( "oldRecordNumber set to %lu", oldRecordNumber);
		}
		else
		{
			// If last transferred application block number is smaller than
			// the last committed block number (or block before first sent
			// if no committed) or higher than the last possible
			// transferred block number (oldRecordNumber + 1)
			if (blockFromOpen < (bpMapper->getApplBlockId(cdhOutVar.theBlockID)-1) ||
					blockFromOpen > (oldRecordNumber + 1))
			{
				// Update last committed block with new CDRB
				bpMapper->readFromTempFile(id, RPCName);				//For TR HH72418   
				AES_CDH_TRACE_MESSAGE( "CDRBid set to %d ", id);
			}
			AES_CDH_TRACE_MESSAGE( "oldRecordNumber ==%lu ", oldRecordNumber);
		}
	}

	inBGWRPCopen = false;
	BGWRPCopen->signal();

	if (returnCode == AES_CDH_RC_OK )
	{
		// cease alarm EXCEPT with write error


		AES_CDH_TRACE_MESSAGE( "Calling cease with destination %s", destinationName.c_str());
		DestinationAlarm::instance()->cease(destinationName,
				destinationPtr->getDestSetName(),
				DestinationAlarm::AlarmRecord::write_error);
	}

	AES_CDH_TRACE_MESSAGE("Leaving...");
	return returnCode;
}


//******************************************************************************
//  openAfterChange()
//******************************************************************************
//##ModelId=3DE49B4D01DC
AES_CDH_ResultCode BGWRPC::openAfterChange()
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	AES_CDH_TRACE_MESSAGE("Entering...");

	AES_CDH_ResultCode returnCode = AES_CDH_RC_OK;
	string RPCName = this->destinationName;
	bpMapper->makeRPCName(RPCName);
	bool b = bpMapper->open(fileName, RPCName);
	if (b != true)
	{
		bpMapper->close();
		return AES_CDH_RC_PHYSFILEERR;
	}


	// If we don't have a client, we need to create one
	if (client == NULL)
	{
		AES_CDH_Contactor conP(this,const_cast<char *>(hostAddress.c_str()),bgwProgramNumber);
		client = conP.getResult();

		AES_CDH_TRACE_MESSAGE("After: this->create()");
		if (client != NULL)
		{
			AES_CDH_TRACE_MESSAGE("client != NULL");
			struct timeval tv;
			tv.tv_sec = bgwTimeout;
			tv.tv_usec = 0;

			if (!clnt_control((CLIENT*)client, CLSET_TIMEOUT, (char*)&tv))  //llv5
			{
				close_internal();
			}
		}
	}

	// If there is no connection
	if (client == NULL)
	{
		ostringstream err_back;
		err_back << "Error: (" << clnt_spcreateerror("BGWRPC")        
				 << ") when connecting to " << hostAddress
				 << " with program number " << bgwProgramNumber;
		Event::report(AES_CDH_rpcConnectFault, "RPC CONNECT ERROR",
				err_back.str(), "-");
		returnCode = AES_CDH_RC_CONNECTERR;
	}
	else
	{
		// cease alarm EXCEPT with write error
		DestinationAlarm::instance()->cease(destinationName,
				destinationPtr->getDestSetName(),
				DestinationAlarm::AlarmRecord::write_error);

		if (updateBlockID() != AES_CDH_RC_OK)
		{
			close_internal();
			return AES_CDH_RC_CONNECTERR;
		}

		unsigned int id;

		// get CDRBid value (== lastTransactionID)
		if (cdhOutVar.theBlockID == 0)
		{
			id = 4294967295;
		}
		else
		{
			id = cdhOutVar.theBlockID - 1;
		}

		AES_CDH_TRACE_MESSAGE( "CDRBid fetched from BGW-server:%d ", id);

		// Initiate CDRBid value if uncommitted
		if (! bpMapper->validFile())
		{
			string RPCName = this->hostAddress;
			bpMapper->makeRPCName(RPCName);
			bpMapper->setCDRBid(id, RPCName);
			AES_CDH_LOG(LOG_LEVEL_DEBUG, "file NOT valid, CDRBid set to %u ", id);
		}
	}

	if (oldRecordNumber == APPLID_MAX + 1)
		oldRecordNumber = bpMapper->getApplBlockId();

	AES_CDH_TRACE_MESSAGE("Leaving ...");
	return returnCode;
}


//******************************************************************************
//  close()
//******************************************************************************
//##ModelId=3DE49B4D01E6
void BGWRPC::close(void)
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	AES_CDH_TRACE_MESSAGE("Entering ... External call...");

	if (client != NULL)
	{
		clnt_destroy((CLIENT*)client); 
		client = NULL;
	}

	if (bpMapper != NULL)
	{
		bpMapper->close();
	}

	AES_CDH_TRACE_MESSAGE(" signaling InstanceClosed Event");
	hEvInstanceClosed->signal();
	AES_CDH_TRACE_MESSAGE("Leaving ... ");
}


//******************************************************************************
//  close_internal()
//******************************************************************************
void BGWRPC::close_internal(void)
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	AES_CDH_TRACE_MESSAGE("Entering ...Internal call...");

	if (client != NULL)
	{
		clnt_destroy((CLIENT*)client);
		client = NULL;
	}

	if (bpMapper != NULL)
	{
		bpMapper->close();
	}

	AES_CDH_TRACE_MESSAGE("Leaving ... Internal call...");
}


//******************************************************************************
//  sendRecord()
//******************************************************************************
//##ModelId=3DE49B4D0204
AES_CDH_ResultCode BGWRPC::sendRecord(void* buf, unsigned long bufSize,
		unsigned long recordNumber)
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	answerCode *returnCode = NULL;

	cdhOutVar.theBlockData.theBlockData_len = bufSize;
	cdhOutVar.theBlockData.theBlockData_val = (unsigned char *)buf;

	if (switchState == AGENT_STOP)
	{
		switchState = AGENT_OK;
		return AES_CDH_RC_SWITCH;
	}

	if (client == NULL)
	{
		return AES_CDH_RC_CONNECTERR;
	}

	if (recordNumber != oldRecordNumber + 1)
	{
		// The application block number is not in sequence
		AES_CDH_TRACE_MESSAGE( "recordNumber != oldRecordNumber + 1, recordNumber =%lu, oldRecordNumber + 1= %lu ", recordNumber, (oldRecordNumber + 1));
		if (recordNumber <= bpMapper->getApplBlockId())
		{
			// The application block number has 'restarted' from some value,
			// for example, changed from 500 to 1
			unsigned int prevCDRBid = cdhOutVar.theBlockID == 0 ? 4294967295 : cdhOutVar.theBlockID - 1;
			bpMapper->setNextApplBlockId(recordNumber, prevCDRBid);
		}
		else
		{
			// This block is not "wanted", just throw away block and get next block
			AES_CDH_TRACE_MESSAGE("recordNumber > oldRecordNumber + 1 => block skipped!");
			return AES_CDH_RC_SKIPPED;
		}
	}

	returnCode = put_1(&cdhOutVar, (CLIENT*)client);

	if ( returnCode == NULL) 
	{
		AES_CDH_LOG(LOG_LEVEL_DEBUG, "FAILED to send block %lu with CDRBid %lu, returnCode == NULL", recordNumber, cdhOutVar.theBlockID);

		ostringstream err_back;
		struct rpc_err client_error;
		clnt_geterr((CLIENT*)client,&client_error);
		err_back << AES_CDH_RPC::ERROR_CODES << client_error.re_status << " from put_1";

		std::string prblmTxt;
		prblmTxt = AES_CDH_RPC::RPC_CONNECTION_ERROR + this->hostAddress;

		Event::report(AES_CDH_rpcSendFault, AES_CDH_RPC::RPC_SEND_ERROR, err_back.str(), prblmTxt);

		return AES_CDH_RC_SENDERR;
	}
	else if( *returnCode != HANDLED) 
	{
		AES_CDH_LOG(LOG_LEVEL_DEBUG, "FAILED to send block %lu with CDRBid %lu, *returnCode == UNHANDLED", recordNumber, cdhOutVar.theBlockID);

		ostringstream err_back;
		struct rpc_err client_error;
		clnt_geterr((CLIENT*)client,&client_error);
		err_back <<AES_CDH_RPC::ERROR_CODES<<client_error.re_status << "," << returnCode << " from put_1";

		std::string prblmTxt;
		prblmTxt = AES_CDH_RPC::RPC_SEND_FAILED + this->hostAddress;
		Event::report(AES_CDH_rpcSendFault, AES_CDH_RPC::RPC_SEND_ERROR, err_back.str(),prblmTxt);

		if ( *returnCode == UNHANDLED)
		{
			// Reset old block number
			oldRecordNumber = APPLID_MAX + 1;
			bpMapper->setCDRBidOnly(0,"");
			bpMapper->setAllChanged();
		}

		return AES_CDH_RC_SENDERR;
	}
	else
	{
		AES_CDH_TRACE_MESSAGE( "block = %lu sent with CDRBid = %lu",recordNumber,cdhOutVar.theBlockID);

		// theBlockID restarts at 0 when maximum value (4294967295)
		// has been reached
		if (cdhOutVar.theBlockID == 4294967295)
		{
			cdhOutVar.theBlockID = 0;
		}
		else
		{
			cdhOutVar.theBlockID++;
		}		

		//HI84158
		AES_CDH_ResultCode rCode = AES_CDH_RC_OK;
		unsigned int CDRBid = 0;
		rCode = this->lastTransaction(CDRBid);

		BlockPairMapper::PairId id;
		if (rCode == AES_CDH_RC_OK)
		{
			id.applid_ = bpMapper->getApplBlockId(CDRBid);
			id.cdrbid_ = CDRBid;
			id.nextApplid_ = id.applid_ + 1;
			bpMapper->commit(id);
		}
		//HI84158

		AES_CDH_TRACE_MESSAGE( "BGWRPC::sendRecord() oldRecordNumber set to recordNumber = %lu", recordNumber);
		oldRecordNumber = recordNumber;
		return AES_CDH_RC_OK;
	}
}


//******************************************************************************
//  getType()
//******************************************************************************
//##ModelId=3DE49B4D0236
void BGWRPC::getType(string& type)
{
    type = BGWRPCType;
}


//******************************************************************************
//  updateBlockID()
//******************************************************************************
//##ModelId=3DE49B4D0272
AES_CDH_ResultCode BGWRPC::updateBlockID(void)
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	AES_CDH_TRACE_MESSAGE("Entering ...");

	unsigned int CDRBid = 0;
	AES_CDH_ResultCode rcode = this->lastTransaction(CDRBid);

	if(rcode == AES_CDH_RC_INTPROGERR)
	{
		oldRecordNumber = APPLID_MAX +1;
	}
	else if(rcode == AES_CDH_RC_OK)
	{
		if (CDRBid == 4294967295)
		{
			cdhOutVar.theBlockID = 0;
		}
		else
		{
			cdhOutVar.theBlockID = CDRBid + 1;
		}
	}
	AES_CDH_TRACE_MESSAGE("Leaving ...");
	return rcode;
}


//******************************************************************************
//  transactionBegin()
//******************************************************************************
//##ModelId=3DE49B4C02F3
AES_CDH_ResultCode BGWRPC::transactionBegin()
{
	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;
	AES_CDH_TRACE_MESSAGE("Entering ...");

	// (1)  Reply OK/NOTOK

	bCommit = false;
	return rCode;
}


//******************************************************************************
//  transactionEnd()
//******************************************************************************
//##ModelId=3DE49B4C02FD
AES_CDH_ResultCode BGWRPC::transactionEnd(unsigned int &translatedBlockNr)
{
	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;
	AES_CDH_TRACE_MESSAGE("Entering...");

	// (1)  Get the "handled" from the remote receiver
	// (2)  Translate the CDRBid to corresponding application blocknumber
	// (3)  Reply the application blocknumber (to the application)

	if (client == NULL)
	{
		return AES_CDH_RC_CONNECTERR;
	}

	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	unsigned int CDRBid = cdhOutVar.theBlockID == 0 ? 4294967295 : cdhOutVar.theBlockID - 1;
	translatedBlockNr = bpMapper->getApplBlockId(CDRBid);

	AES_CDH_TRACE_MESSAGE("applBlockNr = %u", translatedBlockNr);

	return rCode;
}


//******************************************************************************
//  transactionCommit()
//******************************************************************************
//##ModelId=3DE49B4C0308
AES_CDH_ResultCode BGWRPC::transactionCommit(unsigned int &applBlockNr)
{
	AES_CDH_TRACE_MESSAGE("Entering ...");

	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;

	// (1)  Get the CDRBid number from the remote receiver
	//      (if this fails, reply an errorcode to the application)
	// (2)  Read the corresponding application-blocknumber from the blocknumber-list
	// (3)  Delete all blocknumber-pairs older than the received CDRBid
	// (4)  Reply application blocknumber to the application

	if (client == NULL)
	{
		return AES_CDH_RC_CONNECTERR;
	}

	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	unsigned int CDRBid = 0;
	rCode = this->lastTransaction(CDRBid);

	BlockPairMapper::PairId id;
	if (rCode == AES_CDH_RC_OK)
	{
		id.applid_ = bpMapper->getApplBlockId(CDRBid);
		unsigned int sentApplid = bpMapper->getApplBlockId(cdhOutVar.theBlockID);

		if (id.applid_ > sentApplid)
		{
			// Reset old block number
			oldRecordNumber = APPLID_MAX + 1;
			bpMapper->setCDRBidOnly(0,"");
			bpMapper->setAllChanged();
			return AES_CDH_RC_NOBLOCKNOAVAILABLE;
		}

		if (id.applid_ < sentApplid)
		{
			// Re-synchronize the block number for PUT
			if (CDRBid == 4294967295)
			{
				cdhOutVar.theBlockID = 0;
			}
			else
			{
				cdhOutVar.theBlockID = CDRBid + 1;
			}
		}

		id.cdrbid_ = CDRBid;
		id.nextApplid_ = id.applid_ + 1;
		bpMapper->commit(id);
		applBlockNr = bpMapper->getApplBlockId();
		AES_CDH_TRACE_MESSAGE( "CDRBid = %u, applBlockNr =%u ", CDRBid, applBlockNr);

		oldRecordNumber = bpMapper->getApplBlockId(CDRBid);
	}
	else
	{
		// There is no connection to the remote system
		rCode = AES_CDH_RC_CONNECTERR;
		AES_CDH_LOG(LOG_LEVEL_DEBUG, "return value: AES_CDH_RC_CONNECTERR");
	}
	if ( bgwrpc != NULL && rCode == AES_CDH_RC_OK )
	{
		this->close_internal();
		this->hostAddress = bgwrpc->hostAddress;            
		this->blockRetryDelay = bgwrpc->blockRetryDelay;
		this->blockSendRetries = bgwrpc->blockSendRetries;

		bpMapper->setAllChanged();

		if (this->openAfterChange() == AES_CDH_RC_OK)
		{
			AES_CDH_TRACE_MESSAGE("openAfterChange() returned AES_CDH_RC_OK");

			if (this->lastTransaction(CDRBid) == AES_CDH_RC_OK)
			{
				string RPCName = this->hostAddress;
				bpMapper->makeRPCName(RPCName);

				id.cdrbid_ = CDRBid;
				bpMapper->commitChange(id, RPCName);
				applBlockNr = bpMapper->getApplBlockId();
			}
		}

		delete bgwrpc;
		bgwrpc = NULL;
	}

	if (switchState == AGENT_SWITCH) switchState = AGENT_STOP;
	AES_CDH_TRACE_MESSAGE("Leaving , return value: %d ", applBlockNr);

	return rCode;
}


//******************************************************************************
//  getLastCommittedBlock()
//******************************************************************************
//##ModelId=3DE49B4C0312
AES_CDH_ResultCode BGWRPC::getLastCommittedBlock(unsigned int &applBlockNr)
{
	AES_CDH_TRACE_MESSAGE("Entering ...");

	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;


	// (1)  Get the CDRBid number from the remote receiver
	//      (if this fails, check for last committed in the list and goto (4) )
	// (2)  Read corresponding application blocknumber from the blocknumber-list
	// (3)  Delete all blocknumber-pairs older than the received CDRBid
	// (4)  Reply the application blocknumber to the application.
	//      (If the file is invalid, return error-code to the application)

	ACE_Time_Value tv(0,10*1000); // milliseconds

	int count = 0;
	while ( !ServR::isStopEventSignalled && client == NULL && count++ < 200 )
	{
		ACE_OS::sleep(tv);
	}

	if(inBGWRPCopen)
	{
		AES_CDH_TRACE_MESSAGE("inBGWRPCopen == TRUE: waiting signal from BGWRPC::open");
		BGWRPCopen->wait();
	}
	else
	{
		AES_CDH_TRACE_MESSAGE("inBGWRPCopen == FALSE");
	}

	if (client == NULL)
	{
		AES_CDH_TRACE_MESSAGE("client == NULL: returning AES_CDH_RC_CONNECTERR");
		return AES_CDH_RC_CONNECTERR;
	}     

	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	unsigned int CDRBid = 0;
	rCode = this->lastTransaction(CDRBid);

	if (rCode != AES_CDH_RC_OK)
	{
		return rCode;
	}

	if ( bpMapper->isOpen() )
	{
		if ( !bpMapper->validFile() )
		{
			AES_CDH_LOG(LOG_LEVEL_DEBUG, "BGWRPC::getLastCommittedBlock --> bpMapper->validFile() == false: return value == AES_CDH_RC_NOBLOCKNOAVAILABLE");
			return AES_CDH_RC_NOBLOCKNOAVAILABLE;
		}
	}
	else
	{
		AES_CDH_LOG(LOG_LEVEL_DEBUG, "BGWRPC::getLastCommittedBlock --> bpMapper->isOpen() == false: return value == AES_CDH_RC_NOBLOCKNOAVAILABLE");
		return AES_CDH_RC_CONNECTERR;
	}
	AES_CDH_TRACE_MESSAGE("Block number file is VALID");

	applBlockNr = bpMapper->getApplBlockId(CDRBid);
	oldRecordNumber = applBlockNr; //Fix for HI84158
	AES_CDH_TRACE_MESSAGE("lastTransaction OK: CDRBid = %u,  applBlock = %u", CDRBid, applBlockNr);

#ifdef DEBUGTEST
	cout << " APPLID_MAX = " << APPLID_MAX << endl;
#endif

	if (applBlockNr > APPLID_MAX)
	{
		AES_CDH_LOG(LOG_LEVEL_DEBUG, "BGWRPC::getLastCommittedBlock() --> applBlockNr > APPLID_MAX: return value == AES_CDH_RC_NOBLOCKNOAVAILABLE");
		return AES_CDH_RC_NOBLOCKNOAVAILABLE;
	}

	bCommit = true;
	return rCode;
}


//******************************************************************************
//  transactionTerminate()
//******************************************************************************
//##ModelId=3DE49B4C031C
AES_CDH_ResultCode BGWRPC::transactionTerminate()
{
	AES_CDH_ResultCode rCode = AES_CDH_RC_OK;
	AES_CDH_TRACE_MESSAGE("Entering ...");

	// (1)  Stop sending blocks
	// (2)  Clear the stream from blocks (this is done by DBO)
	// (3)  Reply OK to the application

	// Stop block transfer here
	bTerminate = true;
	return rCode;
}


//******************************************************************************
//  lastTransaction()
//******************************************************************************
//##ModelId=3DE49B4D0286
AES_CDH_ResultCode BGWRPC::lastTransaction(unsigned int &CDRBid)
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	lastTransactionAnswer *answer = NULL;

	char* ptr = fileName;
	char** ptr2 = &ptr;

	AES_CDH_TRACE_MESSAGE("Entering...");

	if (client == NULL)
	{
		AES_CDH_LOG(LOG_LEVEL_ERROR, " BGWRPC::lastTransaction(), client == NULL");
		return AES_CDH_RC_CONNECTERR;
	}

	answer = (lasttransaction_1(ptr2, (CLIENT *)client));

	if ( answer == NULL) 
	{
		ostringstream err_back;
		struct rpc_err client_error;
		clnt_geterr((CLIENT*)client,&client_error);
		err_back << "Error codes : " << client_error.re_status << " from lasttransaction_1";
		Event::report(AES_CDH_rpcSendFault, "RPC SEND ERROR",err_back.str(), "-");

		AES_CDH_LOG(LOG_LEVEL_ERROR, " Leaving BGWRPC::lastTransaction(): client == NULL, err_back =  %s",err_back.str().c_str());
		return AES_CDH_RC_INTPROGERR;
	}
	else
	{
		if( answer->code != HANDLED)
		{
			ostringstream err_back;
			struct rpc_err client_error;
			clnt_geterr((CLIENT*)client,&client_error);
			err_back << "Error codes : " << client_error.re_status << "," << answer->code << " from lasttransaction_1";
			Event::report(AES_CDH_rpcSendFault, "RPC SEND ERROR", err_back.str(), "-");

			AES_CDH_LOG(LOG_LEVEL_ERROR, " Leaving BGWRPC::lastTransaction(): answer->code == UNHANDLED, err_back =  %s", err_back.str().c_str());
			return AES_CDH_RC_INTPROGERR;
		}
	}

	CDRBid = answer->lastTransactionID;
	AES_CDH_TRACE_MESSAGE("Leaving with CDRBid = %u", CDRBid);
	return AES_CDH_RC_OK;
}


//******************************************************************************
//  changeAttr()
//******************************************************************************
//##ModelId=3DE49B4C0339
AES_CDH_ResultCode BGWRPC::changeAttr(TransferAgent *agent)
{
	AES_CDH_TRACE_MESSAGE("Entering...");
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	if ( bgwrpc != NULL )
	{
		delete bgwrpc;
		bgwrpc = NULL;
		AES_CDH_TRACE_MESSAGE("old bgwrpc deleted and set to NULL");
	}

	bgwrpc = dynamic_cast<BGWRPC*>(agent);

	AES_CDH_ResultCode rcode = AES_CDH_RC_OK;

	// If there is no on-going transfer, change now...
	if ( (NULL == client)  && (NULL != bgwrpc))
	{
		AES_CDH_TRACE_MESSAGE("BGWRPC::changeAttr update values FROM: hostAddress:<%s>, retryDelay:<%s>, sendRetries:<%s>", hostAddress.c_str(), blockRetryDelay.c_str(), blockSendRetries.c_str());

		hostAddress = bgwrpc->hostAddress;
		blockRetryDelay = bgwrpc->blockRetryDelay;
		blockSendRetries = bgwrpc->blockSendRetries;

		AES_CDH_TRACE_MESSAGE("BGWRPC::changeAttr update values TO: hostAddress:<%s>, retryDelay:<%s>, sendRetries:<%s>", hostAddress.c_str(), blockRetryDelay.c_str(), blockSendRetries.c_str());

		delete bgwrpc;
		bgwrpc = NULL;
	}

	AES_CDH_TRACE_MESSAGE("Leaving...");
	return rcode;
}

//******************************************************************************
//  switchAgent()
//******************************************************************************
//##ModelId=3E2E902E00CB
void BGWRPC::switchAgent(bool stopTransfer)
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);
	// Transfer is in progress, order a stop transfer after commit
	if (stopTransfer)
	{
		AES_CDH_TRACE_MESSAGE("BGWRPC::switchAgent --> stopTransfer is true");
		switchState = AGENT_SWITCH;
	}
	else
		// A switch to a different transfer agent has been performed
	{
		AES_CDH_TRACE_MESSAGE("BGWRPC::switchAgent --> stopTransfer is false");
		bpMapper = BlockPairMapperManager::instance()->getMapper(destinationPtr->getDestSetName());
		if (bpMapper != NULL)
		{
			// Reset old block number
			oldRecordNumber = APPLID_MAX + 1;
			bpMapper->setAllChanged();
		}
		else
		{
			Event::report(AES_CDH_memoryFault, "MEMORY ALLOCATION PROBLEM",
					"Storage space for block mapping could not be allocated", "-");
		}
	}
}


//******************************************************************************
//  changeAfterTerminate()
//******************************************************************************
//##ModelId=3E799A6A02CE
void BGWRPC::changeAfterTerminate()
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);

	// Terminate without commit && changeAttr to do
	if (bgwrpc != NULL)
	{
		AES_CDH_TRACE_MESSAGE("BGWRPC::changeAfterTerminate update values FROM: hostAddress:<%s>, retryDelay:<%s>, sendRetries:<%s>", hostAddress.c_str(), blockRetryDelay.c_str(), blockSendRetries.c_str());

		hostAddress = bgwrpc->hostAddress;
		blockRetryDelay = bgwrpc->blockRetryDelay;
		blockSendRetries = bgwrpc->blockSendRetries;

		AES_CDH_TRACE_MESSAGE("BGWRPC::changeAfterTerminate update values TO:  hostAddress:<%s>, retryDelay:<%s>, sendRetries:<%s>", hostAddress.c_str(), blockRetryDelay.c_str(), blockSendRetries.c_str());
		delete bgwrpc;
		bgwrpc = NULL;
	}
}

//******************************************************************************
//  dataTransfer()
//******************************************************************************
//##ModelId=3E799AC70354
bool BGWRPC::dataTransfer()
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);

	bool retValue(false);
	if (client != NULL)
		retValue = true;

	return retValue;
}

//******************************************************************************
//  getAttributes()
//******************************************************************************
//
//##ModelId=3E81614C03C8
AES_CDH_ResultCode BGWRPC::getAttributes(string& transferType, vector<string>& attr)
{
	ACE_Guard<ACE_Recursive_Thread_Mutex> guard(*transMutex);

	AES_CDH_TRACE_MESSAGE("Entering...");

	getType(transferType);

	AES_CDH_TRACE_MESSAGE("BGWRPC::getAttributes(), After call to: getType(transferType)");

	if (hostAddress != "")
	{
		attr.push_back("-a");
		attr.push_back(hostAddress);
	}

	if (blockRetryDelay != "")
	{
		attr.push_back("-m");
		attr.push_back(blockRetryDelay);
	}

	if (blockSendRetries != "")
	{
		attr.push_back("-s");
		attr.push_back(blockSendRetries);
	}

	AES_CDH_TRACE_MESSAGE("Leaving ...");

	return AES_CDH_RC_OK;
}

//******************************************************************************
// Method getSingleAttr
//******************************************************************************
AES_CDH_ResultCode BGWRPC::getSingleAttr(const char* opt, void* value)
{
	(void)*opt;
	(void)value;
	return AES_CDH_RC_OK;
}
